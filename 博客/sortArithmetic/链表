LRU缓存淘汰算法


常见缓存淘汰策略
1.先进先出策略 FIFO
2.最少使用策略 LFU
3.最近最少使用策略 LRU

数据和链表内存存储不同
数据:连续的内存空间，如果我们申请一个100MB大小的数组，当内存没有连续的，足够大的存储空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败
链表:它并不需要一块连续的内存空间，它通过"指针"将一组零散的内存块串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。



链表结构
查询时间O(n)
1.单链表
链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表里的"结点"。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点地址的指针叫做后继指针 next
关键名称
第一个结点:头结点
头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。
最后一个结点:尾结点
尾节点:指针不是指向下一个结点，而是指向一个空地址NULL,表示这是链表上最后一个结点。


2.双向链表
双向链表，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。
支持双向遍历

双向链表可以更快的删除数据 因为双向链表拿前置结点时间O(1) ，单链表拿前置结点O(N)


3.循环链表
循环链表跟单链表的区别就是循环链表的尾结点指向链表的头结点。




番外内容
引用和指针都是一样的指向内存的地址
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

哨兵：解决边界问题