                                                             数组
为什么数组要从0开始编号，而不是从1开始？
因为计算数据的内存地址的位置是从0开始的，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

如何实现随机访问？
数组:array是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

线性表
线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向，例如，数组，链表，队列，栈。

非线性表
数据之间并不是简单的前后关系。例如:二叉树，堆,图等。

连续的内存空间和相同的数据类型
这两个条件能使数组有一个杀手锏 "随机访问"
优缺点
查询效率高 O(1)
删除，插入效率低 O(n)

计算元素存储的内存地址:
a[i]_address = base_address + i * data_type_size
data_type_size 数组中每个元素的大小
但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

内容总结
数组:它可以说是最基础，最简单的数据结构了，数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入，删除操作也因此变得比较低效，平均情况的时间复杂度为O(n).
在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更适合。


思考
1.前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。

JVM标记清除算法
大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活，只有当标记工作完成后，清理工作才会开始。

不足: 1.效率问题，标记和清理效率都不高，但是当知道只有好靓垃圾产生时会很搞笑。2空间问题。会产生不连续的内存空间碎片。

二维数组内存寻址：
对于 m*n的数组， a[i][j](i<m,j<n)的地址为
address=base_address+(i*n*j)*type_size
另外，对于数组访问越界造成无限循环，我理解时编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配老师的程序，如果时内存地址递减的方式,就会造成无限循环。

2.前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？