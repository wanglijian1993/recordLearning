##状态管理概述
状态管理机制;在声明式UI编程框架中，UI是程序状态的运行结果，用户构建饿了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，
UI作为返回结果，也将运行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。

### 基本概念
<ul>
<li>状态变量:被状态装饰器装饰的变量，状态变量值的改变会引起UI的渲染更新。示例:@State num:number=1,其中，@State是状态装饰器，num是状态变量。</li>
<li>常规变量:没有被状态装饰器装饰的变量，统称应用于辅助计算。它的改变永远不会引起UI的刷新。</li>
<li>数据源/同步源：状态变量的原始来源，可以同步给不同的状态数据。通常意义为父组件传给子组件的数据。以下示例中数据源为count: 1。</li>
<li>命名参数机制：父组件通过指定参数传递给子组件的状态变量，为父子传递同步参数的主要手段。示例：CompA: ({ aProp: this.aProp })。</li>
</ul>
### 饰器总览
<ul>
<li>ArkUi提供了多种装饰器，通过使用这些装饰器，状态变量不仅可以观察在组件内的改变，还可以在不同组件层级间传递，比如父子组件，跨组件层级，也可以观察全局范围内的变化。根据状态变量的影响范围，将所有的装饰可以大致分为 ：</li>
 <li>管理组件拥有的状态的装饰器:组件级别的状态管理，可以观察组件内变化，和不同组件层级的变化，但需要唯一观察同一个组件树上，即同一个页面内。<li>
 <li>管理应用拥有状态的装饰器:应用级别的状态管理，可以观察不同页面，甚至不同UIAbility的状态变化，是应用内全局的状态管理。<li>
 数据的传递形式和同步类型层面看:装饰器也可分为：
<li> 只读的单向传递；</li>
<li> 可变更的双向传递</li>
 </ul>
### 管理组件拥有的状态，即图中Components级别的状态管理
<ul>
<li>
@State:@State装饰的变量拥有其所属组件的状态，可以作为其子组件单向和双向同步的数据源。当其数值改变时，会引起相关组件的渲染刷新。
</li>
<li>@Prop：@Prop装饰的变量可以和父组件建立单向同步关系，@Prop装饰的变量是可变的，但修改不会同步回父组件。</li>
<li>@Link：@Link装饰的变量可以和父组件建立双向同步关系，子组件中@Link装饰变量的修改会同步给父组件中建立双向数据绑定的数据源，父组件的更新也会同步给@Link装饰的变量。</li>
<li>@Provide/@Consume：@Provide/@Consume装饰的变量用于跨组件层级（多层组件）同步状态变量，可以不需要通过参数命名机制传递，通过alias（别名）或者属性名绑定。</li>
<li>@Observed：@Observed装饰class，需要观察多层嵌套场景的class需要被@Observed装饰。单独使用@Observed没有任何作用，需要和@ObjectLink、@Prop连用。</li>
<li>@ObjectLink：@ObjectLink装饰的变量接收@Observed装饰的class的实例，应用于观察多层嵌套场景，和父组件的数据源构建双向同步。</li>
</ul>


@
