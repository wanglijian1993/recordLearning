

# 启动篇1

## 一.启动概述

##  1.1架构图

####  1.1.1架构图

![](https://github.com/wanglijian1993/recordLearning/blob/main/%E8%B5%84%E6%BA%90%E5%9B%BE%E7%89%87/Android%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

#### 1.1.2流程图

![](https://github.com/wanglijian1993/recordLearning/blob/main/%E8%B5%84%E6%BA%90%E5%9B%BE%E7%89%87/Android%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

## 二. init.cpp main入口开始分析

```
int main(int argc, char** argv) {


    //umask函数设置文件属性 0777 (rwx rws rwx) 4 r 6 r-w  7 r-w-x
    umask(0);
    //设置环境变量
    add_environment("PATH", _PATH_DEFPATH);
    
    //挂载和创建文件夹
    if (is_first_stage) {
        mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
        mkdir("/dev/pts", 0755);
        mkdir("/dev/socket", 0755);
        mount("devpts", "/dev/pts", "devpts", 0, NULL);
        mount("proc", "/proc", "proc", 0, NULL);
        mount("sysfs", "/sys", "sysfs", 0, NULL);
    }

    //mnkod令用于创建Linux中的字符设备文件/dev/__kmsg__
    klog_init();
    //设置输出文件的级别
    klog_set_level(KLOG_NOTICE_LEVEL);
    //创建一块共享的内存空间，用于属性服务(properties属性文件并设置大小(128KB))
    property_init();

    //IO多路复用 初始化epoll功能 O_CLOEXEC 02000000
    epoll_fd = epoll_create1(EPOLL_CLOEXEC);
    if (epoll_fd == -1) {
        ERROR("epoll_create1 failed: %s\n", strerror(errno));
        exit(1);
    }
    //3.初始化信号 
    signal_handler_init();
    //加载default.prop文件
    property_load_boot_defaults();
    //启动属性服务器，此处会调用epoll_ctl设置property fd可读的回调函数通过socket监听PROP_SERVICE_NAME文件
    start_property_service();

    init_parse_config_file("/init.rc");

    action_for_each_trigger("early-init", action_add_queue_tail);

    // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...
    queue_builtin_action(wait_for_coldboot_done_action, "wait_for_coldboot_done");
    // ... so that we can start queuing up actions that require stuff from /dev.
    queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");
    queue_builtin_action(keychord_init_action, "keychord_init");
    queue_builtin_action(console_init_action, "console_init");

    // Trigger all the boot actions to get us started.
    action_for_each_trigger("init", action_add_queue_tail);

    // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random
    // wasn't ready immediately after wait_for_coldboot_done
    queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");

    // Don't mount filesystems or start core system services in charger mode.
    char bootmode[PROP_VALUE_MAX];
    if (property_get("ro.bootmode", bootmode) > 0 && strcmp(bootmode, "charger") == 0) {
        action_for_each_trigger("charger", action_add_queue_tail);
    } else {
        action_for_each_trigger("late-init", action_add_queue_tail);
    }

    // Run all property triggers based on current state of the properties.
    queue_builtin_action(queue_property_triggers_action, "queue_property_triggers");

    while (true) {
        if (!waiting_for_exec) {
            execute_one_command();
            restart_processes();
        }

        int timeout = -1;
        if (process_needs_restart) {
            timeout = (process_needs_restart - gettime()) * 1000;
            if (timeout < 0)
                timeout = 0;
        }

        if (!action_queue_empty() || cur_action) {
            timeout = 0;
        }

        bootchart_sample(&timeout);

        epoll_event ev;
        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &ev, 1, timeout));
        if (nr == -1) {
            ERROR("epoll_wait failed: %s\n", strerror(errno));
        } else if (nr == 1) {
            ((void (*)()) ev.data.ptr)();
        }
    }

    return 0;
}

```

