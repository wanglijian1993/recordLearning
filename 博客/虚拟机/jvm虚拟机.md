# jvm虚拟机

## JVM内存结构

java虚拟机的内存空间分为5个部分

- 程序计算器
- 堆
- java虚拟机栈
- 本地方法栈
- 方法区

![jvm-memory-structure](https://github.com/doocs/jvm/raw/main/docs/images/jvm-memory-structure.jpg)

## JDK1.8和JDK1.7区别

最大的差别就是:元数据区取代了永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于:元素据空间并不在虚拟机中，而是使用本地内存。

### 程序计数器(PC寄存器)

**程数计数器的定义**

程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为Undefined。

**程序计数器的特点**

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
- 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。

**程序计数器的特点**

- 是一块较小的内存空间。
- 线程私有，每条线程都有自己的程序计数器。
- 生命周期，随着线程的创建而创建，随着线程的结束而销毁。
- 是唯一一个不会出现OutOfMemoryError的内存区域。

## 堆

**堆的定义**

堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。

**堆的特点**

- 线程共享，整个java虚拟机只有一个堆，所有的线程都访问统一个堆。
- 在虚拟机启动时创建。
- 时垃圾回收的主要场所。
- 进一步可分为:新生代(Eden区:from Survior，To Survivor)，老年区。

不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。

堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小时可扩展的，因此当线程请求分配内存，但堆已满，且内存已午发再扩展时，就抛出OOM异常。

## Java虚拟机栈(Java栈)

**Java虚拟机栈的定义**

Java虚拟机栈时描述Java方法运行过程的内存模型。

Java虚拟器栈会为每一个即将运行的Java方法创建一块叫做"栈帧"的区域，用于存放该方法运行过程中的一些信息

如：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口信息

![jvm-stack](https://github.com/doocs/jvm/raw/main/docs/images/jvm-stack.jpg)

**压栈出栈过程**

当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。

Java虚拟机栈的栈顶的栈帧时当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈。

方法结束后，当前栈帧被移除，栈帧的返回值变成新的活动栈中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。

***由于Java虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。**

**Java虚拟机栈的特点**

- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需要分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。

- Java虚拟机栈会出现两种异常:StackOverFlowError和OutOfMemoryError。

   StackOverFlowError若Java虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，抛出StackOverFlowError异常。

  OutOfMemoryError若允许动态扩展，那么当线程请求栈时内存用完了，午发动态扩展时，抛出OutOfmemoryError异常。

- Java虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。

## 本地方法栈(C栈)

**本地方法栈的定义**

本地方法栈时为JVM运行Native方法准备的空间，由于很多Native方法都是用C语言实现的，所以它通常又叫C栈。它与Java虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

**栈帧变化过程**

本地方法被执行时，载本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表，操作数栈，动态链接，方法出口信息等。

方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出StackoverFlowError和OutOfMerroryError异常。

***如果Java虚拟机本身不支持Native方法，或时本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一版会在线程创建的时候按线程分配。**

## 方法区

**方法区的定义**

Java虚拟机规范中定义方法区是堆的一个逻辑部分，方法区存放以下信息:

- 已经被虚拟机加载的类信息
- 常量
- 静态变量
- 即时编译器编译后的代码

方法区的特点

- 线程公线，方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的，整个虚拟机中只有一个方法区。
- 永久代，方法区的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆划分方法，把方法区称为"永久代"。
- 内存回收效率低，方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是:对常量池的回收；堆类型的卸载。
- Java虚拟机规范堆方法区的要求比较宽松。和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。

**运行时常量池**

方法区中存放:类信息，常量，静态变量，即时编译器编译后的代码。常量就存放在运行时常量池中。

当类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如String类的intern()方法就能在运行期间向常量池中添加字符串常量。

## **直接内存(堆外内存)**

直接内存时除Java虚拟机之外的内存，但也可能被Java使用。

**操作直接内存**

在NIO中引入了一个基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中在进行操作，从而提高了数据操作的效率。

直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM异常。

**直接内存与堆内存比较**

- 直接内存申请空间耗费更高的性能
- 直接内存读取IO的性能优于普通的堆内存
- 直接内存作用链:本地IO->直接内存->本地IO

**服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。**