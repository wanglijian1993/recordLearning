# Android开发高手课

## 崩溃

### Java崩溃

### Native崩溃

native代码的崩溃捕获机制及实现

https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?

Native 崩溃从捕获到解析要经历哪些流程

![img](https://static001.geekbang.org/resource/image/95/11/95d9733860e3a52c6c3b5976ca25b711.jpg)

Chromium 的Breakpad是目前 Native 崩溃捕获中最成熟的方案



### ANR

. 1    使用 FileObserver 监听 /data/anr/traces.txt 的变化。

2. 监控消息队列的运行时间。这个方案无法准确地判断是否真正出现了 ANR 异常，也无法得到完整的 ANR 日志。在我看来，更应该放到卡顿的性能范畴。APP退出的情形

1. 主动杀死，Process.killProcess().exit()等
2. 崩溃 java或Natie崩溃
3. 系统重启；系统出现异常，断电，用户主动重启等，我们可以通过比较应用开机运行时间是否比之前记 

我们可以在应用启动的时候设定一个标志，在主动自杀或崩溃后更新标志， 这样下次启动的时候通过检测这个标志就能确定运行期间是否发生过异常退出。对应上面的五种退出场景，我们排除掉主动自杀和崩溃(崩溃会单独的统计)这两种场景，希望可以监控到剩下三种的异常退出，理论上这个异常捕获机制是可以达到 100% 覆盖的。

### 异常率

UV 异常率 = 发生异常退出或崩溃的 UV / 登录 UV

### logcat

系统的 event logcat 会记录 App 运行的一些基本情况，记录在文件 /system/etc/event-log-tags 中。mnbvcxz

## 崩溃现场

### 崩溃信息

从崩溃的基本信息，我们可以对崩溃有初步的判断。

- 进程名、线程名。崩溃的进程是前台进程还是后台进程，崩溃是不是发生在 UI 线程。
- 崩溃堆栈和类型。崩溃是属于 Java 崩溃、Native 崩溃，还是 ANR，对于不同类型的崩溃我们关注的点也不太一样。特别需要看崩溃堆栈的栈顶，看具体崩溃在系统的代码，还是我们自己的代码里面。

```
system logcat:
10-25 17:13:47.788 21430 21430 D dalvikvm: Trying to load lib ... 
event logcat:
10-25 17:13:47.788 21430 21430 I am_on_resume_called: 生命周期
10-25 17:13:47.788 21430 21430 I am_low_memory: 系统内存不足
10-25 17:13:47.788 21430 21430 I am_destroy_activity: 销毁 Activty
10-25 17:13:47.888 21430 21430 I am_anr: ANR 以及原因
10-25 17:13:47.888 21430 21430 I am_kill: APP 被杀以及原因
```

- 机型、系统、厂商、CPU、ABI、Linux 版本等。我们会采集多达几十个维度，这对后面讲到寻找共性问题会很有帮助。
- 设备状态：是否 root、是否是模拟器。一些问题是由 Xposed 或多开软件造成，对这部分问题我们要区别对待。

### 系统信息

Logcat。这里包括应用、系统的运行日志。由于系统权限问题，获取到的 Logcat 可能只包含与当前 App 相关的。其中系统的 event logcat 会记录 App 运行的一些基本情况，记录在文件 /system/etc/event-log-tags 中。

### 内存信息

- 系统剩余内存。关于系统内存状态， 可以直接读取文件/proc/meminfo。当系统可用内存很小(低于MemTotal的10%)时，OOM，大量GC，系统频繁自杀拉起等问题都非常容易出现。
- 应用使用内存。包括Java内存，RSS(Resident Set Size),PSS(Proportional Set Size)，我们可以得出应用本身内存的占用大小和分布。PSS和RSS通过 /proc/self/smap/计算，可以进一步得到例如APK，dex，so等更加详细的分类统计。
- 虚拟内存。虚拟内存可以通过/proc/self/status 得到，通过/proc/self/maps 文件可以得到具体的分布情况。有时我们一般不太重视虚拟内存，但是很多类似OOM。tgkill等问题都是虚拟内存不足导致的。

```
Name:     com.sample.name   // 进程名
FDSize:   800               // 当前进程申请的文件句柄个数
VmPeak:   3004628 kB        // 当前进程的虚拟内存峰值大小
VmSize:   2997032 kB        // 当前进程的虚拟内存大小
Threads:  600               // 当前进程包含的线程个数
```

一般来说，对于 32 位进程，如果是 32 位的 CPU，虚拟内存达到 3GB 就可能会引起内存申请失败的问题。如果是 64 位的 CPU，虚拟内存一般在 3～4GB 之间。当然如果我们支持 64 位进程，虚拟内存就不会成为问题。Google Play 要求 2019 年 8 月一定要支持 64 位，在国内虽然支持 64 位的设备已经在 90% 以上了，但是商店都不支持区分 CPU 架构类型发布，普及起来需要更长的时间。

### 资源信息

- 有的时候我们会发现应用堆内存和设备内存都非常充足，还是会出现内存分配失败的情况，这跟资源泄露可能有比较大的关系。

- 文件句柄fd。文件句柄的限制可以通过 /proc/self/limits获得，一般单个进程允许打开的最大文件句柄个数为1024。但是如果文件句柄超过800个就比较危险，需要将所有的fd以及对应的文件名输出到日志中，进一步排查是否出现了有文件或者线程的泄漏。

- ```
  opened files count 812:
  0 -> /dev/null
  1 -> /dev/log/main4 
  2 -> /dev/binder
  3 -> /data/data/com.crash.sample/files/test.config
  ```

- 
  线程数。当前线程数大小可以通过上面的 status 文件得到，一个线程可能就占 2MB 的虚拟内存，过多的线程会对虚拟内存和文件句柄带来压力。根据我的经验来说，如果线程数超过 400 个就比较危险。需要将所有的线程 id 以及对应的线程名输出到日志中，进一步排查是否出现了线程相关的问题。

- ```
   threads count 412:               
   1820 com.sample.crashsdk                         
   1844 ReferenceQueueD                                             
   1869 FinalizerDaemon   
    
  ```

- JNI。使用 JNI 时，如果不注意很容易出现引用失效、引用爆表等一些崩溃。我们可以通过 DumpReferenceTables 统计 JNI 的引用表，进一步分析是否出现了 JNI 泄漏等问题。

### 崩溃分析

Native 崩溃。需要观察 signal、code、fault addr 等内容，以及崩溃时 Java 的堆栈。关于各 signal 含义的介绍，你可以查看崩溃信号介绍。比较常见的是有 SIGSEGV 和 SIGABRT，前者一般是由于空指针、非法指针造成，后者主要因为 ANR 和调用 abort() 退出所导致。

ANR。我的经验是，先看看主线程的堆栈，是否是因为锁等待导致。接着看看 ANR 日志中 iowait、CPU、GC、system server 等信息，进一步确定是 I/O 问题，或是 CPU 竞争问题，还是由于大量 GC 导致卡死。

**Debugger、GDB调试工具**



## 内存优化

![image-20220106164400096](C:\Users\wanglj\AppData\Roaming\Typora\typora-user-images\image-20220106164400096.png)

**内存占用过多会出现OOM和卡顿问题**

### OOM

内存分配失败这些崩溃，也包括因为整体内存不⾜导致应⽤被杀死、设备重启等问题

#### 卡顿

java内存不足会导致频繁GC，这个问题在Dalvik虚拟机会更加明显，而Art虚拟机在内存管理跟回收策略上都做大量优化，内存分配和GC效率都想比提升了5-10呗。

**提醒:1.PSS:虚拟内存，PSS:物理内存 2.内存合理应用：用时分配，及时释放**

### BItmap大内存存储模式

Android3.0之前，Bitmap对象放在Java堆，而像素数据是放在Native内存中。如果不手动调用recycle，Bitmap Native内存的回收完全依赖finalize函数回调，熟悉Java的同学应该知道，这个时机不可控。

Android3.0~Android7.0将Bitmap对象和像素统一放在Java堆中，这样就算我们不调用recycle,Bitmap内存也会随着对象一起被回收，不过Bitmap是内存消耗的大户，把它的内存放在Java堆中似乎不是那么美妙。Java堆有最大限制当堆内存占用超过他的限制就会出现OOM，Bitmap放到Java堆的另一个问题会引起大量的GC，对系统内存也没有完成利用起来。

可以将BItmap存放到Native中，也可以做到和对象一起快速释放，同时GC的时候也能考虑这些内存防止被滥用？NativeAllocationRegistry可以一次满足这三个要求，Android8.0正式使用这个辅助回收Native内存的机制，来实现像素数据放到Native内存中。Android8.0还新增了硬件位图Hardware Bitmap，它可以减少图片内存提升绘制效率。

**系统物理内存不⾜时，lmk开始杀进程，从后台、桌⾯、服务、前台，直到⼿机重启**

**Java堆内存分析工具Allocation Tracker和MAT**

### 内存优化

#### 设备分级

**内存优化首选需要根据设备环境来综合考虑**，内存优化的一个误区"内存占用越少越好"。其实我们可以让高端设备使用更多的内存，做到针对设备性能的好坏使用不同的内存分配和回收策略。

- 设备分级，使用类似device-year-class的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者某些功能，使用555格式的图片，使用更小的缓存内存等。
- 缓存管理.我们需要有一套统一的缓存管理机制，可以适当地使用内存，当系统有难时，也要义不容辞的归还。我们可以使用OnTrimMemory回调，根据不同的状态决定释放多少内存。对于大项目来说，可能存在几十上百个模块，统一缓存管理可以更好地监控每个模块的缓存大小。
- 进程模型.一个空的进程也会占用10MB的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活。所以减少应用启动的进程数，减少常驻进程，有节操的保活，对低端机内存优化非常重要。
- 安装包大小，安装包中的代码，资源，图片以及so库的体积，跟它们占用的内存有大小的关系。一个80MB的引用很难再512MB内存的手机上流畅运行。这种情况我们要考虑针对低端机用户推出4MB的轻量版本，例如Facebook Lite，今日头条极速版都是这个思路。

### BItmap优化

即使把所有的Bitmap都放到Native内存，并不代表图⽚内存问题就完全解决了，这样做只是提升了系统内存利⽤率，减少了GC带来的⼀些问题⽽已。

#### 统一图片库

图片内存优化的前提是收拢图片的使用，这样我们可以做整体的控制策略。例如低端机使用565格式，更加严格的缩放算法，可以使用Glide比较优秀的图片加载库，而且需要进一步将所有的Bitmap.createBitmap,BitmapFactory相关的接口也一并收拢。

#### 方法二，统一监控

在统⼀图⽚库后就⾮常容易监控Bitmap的使⽤情况了，这⾥主要有三点需要注意。

- ⼤图⽚监控。我们需要注意某张图⽚内存占⽤是否过⼤，例如⻓宽远远⼤于View甚⾄是屏幕的⻓宽。在开发过程中，如果检测到不合规的图⽚使⽤，应该⽴即弹出对话框提示图⽚所在的Activity和堆栈，让开发同学更快发现并解决问题。在灰度和线上环境下可以将异常信息上报到后台，我们可以计算有多少⽐例的图⽚会超过屏幕的⼤⼩，也就是图⽚的“**超宽率**”。
- 重复图⽚监控。重复图⽚指的是Bitmap的像素数据完全⼀致，但是有多个不同的对象存在。这个监控不需要太多的样本量，⼀般只在内部使⽤。**之前我实现过⼀个内存Hprof的分析⼯具，它可以⾃动将重复Bitmap的图⽚和引⽤链输出**。下图:是⼀个简单的例⼦，你可以看到两张图⽚的内容完全⼀样，通过解决这张重复图⽚可以节省1MB内存。

图片总内存。通过收拢图片使用，我们还可以统计应用所有图片占用的内存，这样在线上就可以按不同的系统，屏幕分辨率等维度去分析图片内存的占用情况。**在OOM崩溃的时候，也可以把图片占用的内存，TOPN图片的内存都写到崩溃日志中，帮助我们排查问题。**

### 内存泄漏

内存泄漏简单来说就是没有回收不再使⽤的内存，排查和解决内存泄漏也是内存优化⽆法避开的⼯作之⼀。

内存泄露主要分二种情况，一种是同一个对象泄露，还有一种情况更加糟糕，就是每次都会泄露新的对象，可能会出现几百上千个无用的对象。

### 内存监控

前⾯我也提了内存泄漏的监控存在⼀些性能的问题，⼀般只会对内部⼈员和极少部分的⽤户开启。在线上我们需要通过其他更
有效的⽅式去监控内存相关的问题。
1. **采集⽅式**
    ⽤户在前台的时候，可以每5分钟采集⼀次PSS、Java堆、图⽚总内存。我建议通过采样只统计部分⽤户，需要注意的是要按
    照⽤户抽样，⽽不是按次抽样。简单来说⼀个⽤户如果命中采集，那么在⼀天内都要持续采集数据。

2. **计算指标**
    通过上⾯的数据，我们可以计算下⾯⼀些内存指标。

  

  **内存异常率**：可以反映内存占⽤的异常情况，如果出现新的内存使⽤不当或内存泄漏的场景，这个指标会有所上涨。其中PSS的值可以通过Debug.MemoryInfo拿到。

  ```
  内存 UV 异常率 = PSS 超过 400MB 的 UV / 采集 UV
  ```

  

  **触顶率：**可以反映Java内存的使⽤情况，如果超过85%最⼤堆限制，GC会变得更加频繁，容易造成OOM和卡顿。

  ```
  内存 UV 触顶率 = Java 堆占⽤超过最⼤堆限制的 85% 的 UV / 采集 UV
  ```

  其中是否触顶可以通过下⾯的⽅法计算得到。

```
long javaMax = runtime.maxMemory();
long javaTotal = runtime.totalMemory();
long javaUsed = javaTotal - runtime.freeMemory();
// Java 内存使⽤超过最⼤限制的 85%
float proportion = (float) javaUsed / javaMax;
```

⼀般客户端只上报数据，所有计算都在后台处理，这样可以做到灵活多变。后台还可以计算平均PSS、平均Java内存、**平均图⽚占⽤**这些指标，它们可以反映内存的平均情况。通过平均内存和分区间内存占⽤这些指标，我们可以通过版本对⽐来监控有没有新增内存相关的问题。

3. **GC监控**

```
// 运⾏的GC次数
Debug.getRuntimeStat("art.gc.gc-count");
// GC使⽤的总耗时，单位是毫秒
Debug.getRuntimeStat("art.gc.gc-time");
// 阻塞式GC的次数
Debug.getRuntimeStat("art.gc.blocking-gc-count");
// 阻塞式GC的总耗时
Debug.getRuntimeStat("art.gc.blocking-gc-time");
```

## 卡顿优化

**java层:Traceview 和 systrace 都是我们比较熟悉的排查卡顿的工具**

**Native层Simpleperf性能分析工具**

如果需要分析 Native 代码的耗时，可以选择 Simpleperf；如果想分析系统调用，可以选择 systrace；如果想分析整个程序执行流程的耗时，可以选择 Traceview 或者插桩版本的 systrace。

Facebook 的 Profilo 实现了快速获取 Java 堆栈，其实它参考的是 JVM 的 AsyncGetCallTrace 思路，然后适配 Android Runtime 的实现。systrace 使用的是 Linux 的 ftrace，Simpleperf 参考了 Linux 的 perf 工具。还是熟悉的配方，还是熟悉的味道，我们很多创新性的东西，其实还是基于 Java 和 Linux 十年前的产物